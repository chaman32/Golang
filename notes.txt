package api

import (
	"bufio"
	"context"
	"fmt"
	"kvstore/internal/service"
	"log"
	"net"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"syscall"
)

func handleConn(conn net.Conn) {
	defer conn.Close()
	sc := bufio.NewScanner(conn)
	for sc.Scan() {
		line := strings.TrimRight(sc.Text(), "\r\n")
		id, result, value := processLine(line)
		if _, err := fmt.Fprintf(conn, "%s|%s|%s\n", id, result, value); err != nil {
			return
		}
	}
}

func processLine(line string) (id, result, value string) {
	parts := strings.Split(line, "|")
	// Ensure at least id + op + key
	if len(parts) < 3 {
		return safeIdx(parts, 0), "ERROR", ""
	}
	id = parts[0]
	op := strings.ToUpper(parts[1])
	key := parts[2]
	data := parts[3]

	log.Print("key ", key)

	switch op {
	case "GET":

		return get(key, id)

	case "SET":
		return set(parts, id, data)

	case "DELETE":
		return delete(key, id)

	default:
		return id, "ERROR", ""
	}
}

func delete(key string, rid string) (id, result, value string) {
	if key == "" {
		return rid, "ERROR", ""
	}
	k, err := strconv.Atoi(key)
	if err != nil {
		return rid, "ERROR", ""
	}

	v, _ := service.Delete(k)
	if v {
		return rid, "OK", ""
	}
	return rid, "NOTFOUND", ""
}

func set(parts []string, rid string, data string) (id, result, value string) {
	if len(parts) < 4 {
		return rid, "ERROR", ""
	}
	v, err := service.Set(service.Data{Id: 0, Value: data})
	if err != nil {
		return rid, "ERROR", ""
	}

	return rid, "OK", strconv.Itoa(v.Id)
}

func get(key, rid string) (id, result, value string) {
	if key == "" {
		return rid, "ERROR", ""
	}

	k, err := strconv.Atoi(key)
	if err != nil {
		return rid, "ERROR", ""
	}

	d, err := service.Get(k)
	if err != nil {

		return rid, "NOTFOUND", ""
	}
	return rid, "OK", d.Value
}

func safeIdx(parts []string, i int) string {
	if i < len(parts) {
		return parts[i]
	}
	return ""
}

func InitTcpServer(tcpPort string) {

	service.Init()

	ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	var wg sync.WaitGroup

	ln, err := net.Listen("tcp", tcpPort)
	
	if err != nil {
		log.Fatalf("TCP listen error: %v", err)
	}
	log.Printf("TCP listening on %s", tcpPort)

	wg.Add(1)

	go func() {
		defer wg.Done()
		defer ln.Close()
		for {
			conn, err := ln.Accept()

			if err != nil {
				if ctx.Err() != nil {
					return
				}
				log.Printf("Accept error: %v", err)
				continue
			}
			go handleConn(conn)

		}

	}()

	go func() {
		<-ctx.Done()
		_ = ln.Close()

	}()

	<-ctx.Done()
	log.Println("Shutting downâ€¦")
	wg.Wait()
	log.Println("Bye.")
}
